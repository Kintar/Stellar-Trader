# Entity System

## Entity
An entity is a reference to a collection of components.  When the entity is disposed due to logic acting on one of its components, then all components associated with the entity are also disposed.

## Manager
A manager is an autotomous processing module that invokes the actions defined on components that are under its control.  These invocations occur based on input such as time, messages from other components, or user input devices like the keyboard and mouse.  Managers can operate in isolation or along with other managers to define a component system, which is simply a named collection of managers and components that rely upon each other to provide behavior to the game.  A component system should be designed in such a way that it has no hard references to other systems; that is, it does not require the code from another system in order to compile.

## Component
A component is a group of property and behavior definitions.  Components are assigned to a system, which determines the behaviors they can reference and the scope of their defined properties.  In brief, a component is a definition of state for an entity within a system.  This state includes properties, currently executing behaviors, and avilable behaviors.

## Behavior
A behavior is a unit of game logic.  Behaviors can complete in a single invocation, or can be functions of time, basing their operation on the length of time since their last invocation or since their starting time.  Behaviors are the things that read and modify the properties defined by a component.  Behaviors are allowed to chain to other behaviors within the same system, but cannot directly invoke behaviors in another system.  (Refer to the requirement that a system not require the presence of another system to compile.)

### To define
* Do we allow behaviors to __QUERY__ properties set by other systems?  If so, is it direct or message-based?

## Property
A property is defined by a component system and holds a typed value.  Properties are only modifiable by the component that defined them, but are queryable by any component in the system.  Properties are associated with an entity, based on the entity's currently assigned components.  When a component is registered with an entity, the properties are assigned, and when a component is removed, the properties are also detached from the entity and destroyed.
Properties may also declare that they are transient or persistent.  Transient properties can be re-calculated by a component when it is assigned to an entity or when certain logic on the component executes, and therefore do not need to be stored when the program exits.  Persistent properties cannot be recalculated from other state, and must be saved into a datastore when the program exits.

## Intra- and inter-system messaging
Messages are used by Managers to determine that another system wants logic to be performed on an entity.  Managers register with a central messaging bus to declare the messages that they respond to.  In its most basic form, a message simply delares the system it serves, its name, and accepts two entity IDs; one for the source of the message, and one as the target entity.  When the message arrives the manager determines if it can act upon the message and, if so, invokes the appropriate method on a component assigned to the target entity.  More advanced messages may accept a list of key/value pairs for extended data associated with the message.

## Persistence
Managers are responsible for marshalling the persistent properties within their system.

### To define
* Is the persist call available per-entity, or does it function on an entire system at once?
* What is the response format?  Are we simply responding in JSON/XML, and expecting the persistence system to compose fragments from each component system into the final storage format?
* How does the overall system respond when properties and components for a system are declared in the persistent store, but the system is not available when the entity is loaded?

## Remaining questions
* How do we manage processing of logic?  Do managers get their update() method called in sequence, or do we define a mechanism to allow managers to declare their threading level, allowing (e.g.) the UI System to run in parallel with the Physics System?
